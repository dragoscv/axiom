
import path from "node:path";
import { sha256, writeFile } from "./util.js";
import type { Manifest, Artifact } from "./manifest.js";
import type { TAxiomIR } from "@axiom/core/dist/ir.js";
import type { Emitter } from "./emitter.js";

// Import emitters statically to avoid dynamic import issues in workspace
import webappEmitterImpl from "../../emitters/webapp/dist/index.js";
import apiserviceEmitterImpl from "../../emitters/apiservice/dist/index.js";
import batchjobEmitterImpl from "../../emitters/batchjob/dist/index.js";
import dockerEmitterImpl from "../../emitters/docker/dist/index.js";

async function getEmitter(subtype: string, profileName?: string): Promise<Emitter | undefined> {
  // Use static imports for workspace emitters
  if (subtype === "web-app") return webappEmitterImpl;
  if (subtype === "api-service") return apiserviceEmitterImpl;
  if (subtype === "batch-job") return batchjobEmitterImpl;
  if (subtype === "docker-image") return dockerEmitterImpl;

  // Fallback: try profile mapping for custom emitters
  try {
    const fs = await import("node:fs");
    const pathMod = await import("node:path");
    const cwd = process.cwd();
    const profFile = pathMod.join(cwd, "profiles", (profileName || "default") + ".json");
    if (fs.existsSync(profFile)) {
      const cfg = JSON.parse(fs.readFileSync(profFile, "utf-8"));
      const modName = cfg?.map?.[subtype];
      if (typeof modName === "string") {
        const mod = await import(modName);
        return mod.default;
      }
    }
  } catch { }

  return undefined;
}


export async function generate(ir: TAxiomIR, outRoot = process.cwd(), profile?: string): Promise<{ artifacts: Artifact[]; manifest: Manifest }> {
  const artifacts: Artifact[] = [];
  
  // Deterministic buildId: hash(IR + profile) pentru eliminarea dependenței de timp
  const irNormalized = JSON.stringify(ir, Object.keys(ir).sort());
  const profileNormalized = profile || "default";
  const buildId = sha256(irNormalized + profileNormalized);
  const irHash = sha256(irNormalized);
  
  // createdAt devine deterministic: hash-based timestamp pentru reproducibilitate
  const createdAt = `deterministic-${buildId.substring(0, 16)}`;

  function writer(rel: string, content: string) {
    const { full } = writeFile(outRoot, rel, content);
    const bytes = Buffer.byteLength(content, "utf-8");
    artifacts.push({ path: rel, kind: "file", sha256: sha256(content), bytes });
  }

  for (const agent of ir.agents) {
    for (const item of agent.emit) {
      const subtype = item.subtype ?? (item.type === "service" ? "web-app" : item.type);
      const emitter = await getEmitter(subtype, profile);
      if (!emitter) {
        writer(path.join(item.target, "README.md"), `# ${subtype} (placeholder)\nGenerated by AXIOM.`);
        continue;
      }
      await emitter.generate({
        ir, agent, target: item.target, profile,
        write(filePath, content) {
          const rel = path.join(item.target, filePath);
          writer(rel, content);
        }
      });
    }
  }

  // Rulează checks și populează evidence
  const { check } = await import("./check.js");
  const manifestTemp: Manifest = {
    version: "1.0.0",
    buildId,
    irHash,
    profile,
    artifacts,
    evidence: [],
    createdAt
  };

  const checkResult = await check(manifestTemp, ir, outRoot);

  const manifest: Manifest = {
    ...manifestTemp,
    evidence: checkResult.report
  };

  writer("manifest.json", JSON.stringify(manifest, null, 2));
  return { artifacts, manifest };
}

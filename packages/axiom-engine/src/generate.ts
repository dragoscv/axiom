
import path from "node:path";
import { sha256, writeFile, toPosixPath } from "./util.js";
import type { Manifest, Artifact } from "./manifest.js";
import type { TAxiomIR } from "@codai/axiom-core/dist/ir.js";
import type { Emitter } from "./emitter.js";

// Import emitters from published packages
import webappEmitterImpl from "@codai/axiom-emitter-webapp/dist/index.js";
import apiserviceEmitterImpl from "@codai/axiom-emitter-apiservice/dist/index.js";
import batchjobEmitterImpl from "@codai/axiom-emitter-batchjob/dist/index.js";
import dockerEmitterImpl from "@codai/axiom-emitter-docker/dist/index.js";

async function getEmitter(subtype: string, profileName?: string): Promise<Emitter | undefined> {
  // Use static imports for workspace emitters
  if (subtype === "web-app") return webappEmitterImpl;
  if (subtype === "api-service") return apiserviceEmitterImpl;
  if (subtype === "batch-job") return batchjobEmitterImpl;
  if (subtype === "docker-image") return dockerEmitterImpl;

  // Fallback: try profile mapping for custom emitters
  try {
    const fs = await import("node:fs");
    const pathMod = await import("node:path");
    const cwd = process.cwd();
    const profFile = pathMod.join(cwd, "profiles", (profileName || "default") + ".json");
    if (fs.existsSync(profFile)) {
      const cfg = JSON.parse(fs.readFileSync(profFile, "utf-8"));
      const modName = cfg?.map?.[subtype];
      if (typeof modName === "string") {
        const mod = await import(modName);
        return mod.default;
      }
    }
  } catch { }

  return undefined;
}


export async function generate(ir: TAxiomIR, outRoot = process.cwd(), profile?: string): Promise<{ artifacts: Artifact[]; manifest: Manifest }> {
  const artifacts: Artifact[] = [];

  // Deterministic buildId: hash(IR + profile) pentru eliminarea dependenței de timp
  const irNormalized = JSON.stringify(ir, Object.keys(ir).sort());
  const profileNormalized = profile || "default";
  const buildId = sha256(irNormalized + profileNormalized);
  const irHash = sha256(irNormalized);

  // createdAt devine deterministic: hash-based timestamp pentru reproducibilitate
  const createdAt = `deterministic-${buildId.substring(0, 16)}`;

  function writer(rel: string, content: string) {
    // Normalizează path-ul la POSIX ÎNAINTE de orice stocare în manifest
    const normalizedRel = toPosixPath(rel);
    const result = writeFile(outRoot, normalizedRel, content);
    const contentBuf = Buffer.from(content, "utf-8");

    // VERIFICARE CRITICĂ: Forțăm POSIX path direct din toPosixPath pentru artifacts
    // Ignorăm complet result.posixPath pentru a evita orice posibilă corupție
    const artifactPath = toPosixPath(normalizedRel);

    artifacts.push({
      path: artifactPath,
      kind: "file",
      sha256: sha256(content),
      bytes: contentBuf.byteLength
    });
  }

  for (const agent of ir.agents) {
    for (const item of agent.emit) {
      const subtype = item.subtype ?? (item.type === "service" ? "web-app" : item.type);
      const emitter = await getEmitter(subtype, profile);
      if (!emitter) {
        // Normalizăm item.target la POSIX ÎNAINTE de concatenare
        const normalizedTarget = toPosixPath(item.target);
        const placeholderPath = `${normalizedTarget}/README.md`;
        writer(placeholderPath, `# ${subtype} (placeholder)\nGenerated by AXIOM.`);
        continue;
      }
      await emitter.generate({
        ir, agent, target: item.target, profile,
        write(filePath, content) {
          // Normalizăm AMBELE componente la POSIX ÎNAINTE de concatenare
          const normalizedTarget = toPosixPath(item.target);
          const normalizedFile = toPosixPath(filePath);
          const rel = `${normalizedTarget}/${normalizedFile}`;
          writer(rel, content);
        }
      });
    }
  }

  // CRITICAL FIX: Normalizăm TOATE path-urile din artifacts la POSIX înainte de manifest
  // IMPORTANT: Creăm NOI obiecte (nu shallow copy) pentru a evita mutarea accidentală
  const posixArtifacts = artifacts.map(a => ({
    path: a.path.replace(/\\/g, '/'),
    kind: a.kind,
    sha256: a.sha256,
    bytes: a.bytes
  }));

  // Rulează checks și populează evidence
  const { check } = await import("./check.js");
  const manifestTemp: Manifest = {
    version: "1.0.0",
    buildId,
    irHash,
    profile,
    artifacts: posixArtifacts,
    evidence: [],
    createdAt
  };

  const checkResult = await check(manifestTemp, ir, outRoot);

  const manifest: Manifest = {
    ...manifestTemp,
    evidence: checkResult.report
  };

  writer("manifest.json", JSON.stringify(manifest, null, 2));

  // CRITICAL FIX: Force POSIX normalization on return to eliminate any possibility of backslashes
  // This is a defense-in-depth measure to ensure artifacts are ALWAYS POSIX, even if earlier
  // normalization steps are bypassed or corrupted by external factors
  const finalArtifacts = posixArtifacts.map(a => ({
    ...a,
    path: a.path.replace(/\\/g, '/')
  }));

  const finalManifest: Manifest = {
    ...manifest,
    artifacts: manifest.artifacts.map(a => ({
      ...a,
      path: a.path.replace(/\\/g, '/')
    }))
  };

  return { artifacts: finalArtifacts, manifest: finalManifest };
}
